## ü§∑‚Äç Part 6 of 6: Are We There¬†Yet?

Whether you've chosen to go with the Solution 1 or 2, it seems like it's all working now! Let's close the Browser Developer Tools and enjoy the feeling of accomplishment after a lot of work.

Just to make sure everything is working correctly, let's update our JSON files and add "!!!" at the end of all translation strings to celebrate. Build and start the application. Refresh the page and then‚Ä¶ scratch your head. The "!!!" aren't there. What happened?

While the Browser Developer Tools panel was open, the browser would clear cache on each page reload. It means the browser would download fresh JSON files each time. The moment we closed the Developer Tools panel, the browser started caching our assets. Even though we've changed the contents of the JSON files, the browser does not know about it.

But how does the browser know to load fresh JavaScript and CSS files every time? That's because Angular's build scripts append a unique set of characters (hash) to the file name.

> Image

This hash changes every time when the contents of the file change. We need to implement a similar feature for our JSON files.

Luckily, the implementation is straightforward. Let's create `/scripts` folder and a new file there: `hash-translations.js`.

```js
"use strict";
const fs = require('fs');
const path = require('path');
const md5 = require('md5');
const srcPath = 'src/assets/i18n';
const destPath = 'src/assets/i18n/autogen';

cleanDestinationDir();
const map = generateHashedFiles();
saveHashMapFile(map);

function cleanDestinationDir() {
  console.log("Cleaning existing destinaiton directory");
  if (fs.existsSync(destPath) && fs.statSync(destPath).isDirectory()) {
    const destFiles = fs.readdirSync(destPath);
    destFiles.forEach(function(fileName) {
      fs.unlinkSync(path.join(destPath, fileName));
    });
  } else {
    fs.mkdirSync(destPath);
  }
}

function generateHashedFiles() {
  const map = {};
  const srcFiles = fs.readdirSync(srcPath);
  srcFiles.forEach(function(fileName) {
    if (fileName === 'autogen') { return; }
    const srcFile = path.join(srcPath, fileName);
    console.log('Reading source file: ', srcFile);
    const buf = fs.readFileSync(srcFile);
    const hash = md5(buf);
    const lang = fileName.split('.')[0];
    map[lang] = hash;
    const destFile = path.join(destPath, `${lang}.${hash}.json`);
    console.log('Writing new file:', destFile);
    fs.writeFileSync(destFile, buf);
  });
  return map;
}

function saveHashMapFile(map) {
  const mapFile = path.join(destPath, 'map.json');
  console.log('Writing map file: ', mapFile);
  fs.writeFileSync(mapFile, JSON.stringify(map, null, 2));
}
```

For this script to work, we need to install a new dependency.

```
npm install md5 -D
```

The script file above defines two important variables: the source directory and the destination directory.

First, the script will clean up the destination directory if it was not empty. Then the script will look at the source path specified, read the JSON files, and generate hashes using `md5` based on the files' contents.

Once the hashes are generated, the script will write a copy of each file in the destination directory, but this time with the hash in the file name.

Finally, the script will generate the `map.json` file and put it in the destination directory as well. This file will let us pick the correct hashed file based on the locale. The contents of this file will look like the following:

```json
{
  "en": "[hash-for-file-1]",
  "ru": "[hash-for-file-2]"
}
```

Add an entry to the `package.json` file under the scripts field that will let us execute the file we created.

Also, update the `start` and `build:ssr` scripts to run this new script:

```
"hash:i18n": "node scripts/hash-translations.js",
"start": "npm run hash:i18n && ng serve",
"build:ssr": "npm run hash:i18n && npm run build:client-and-server-bundles && npm run compile:server"
```

Go ahead and run the new script to see the results. Note, that there is no need to check in autogenerated files into the repository since they will be changing often. Add an entry to the¬†`.gitignore` file.

```
src/assets/i18n/autogen/*
```

Finally, update the Translation Loaders to serve autogenerated files.

The path to the file that we need to load looks like this: `./assets/i18n/autogen/${lang}.${hash}.json`. The `./assets/i18n/autogen/` part is the `prefix`. The `.${hash}.json` is the suffix. Both of these variables need to be customized in order to make use of the autogenerated files.

Here's how we can handle the prefix change for both loaders.

```ts
export function translateLoaderFactory(httpClient: HttpClient, transferState: TransferState, platform: any) {
  const prefix = './assets/i18n/autogen/';
  return isPlatformBrowser(platform)
    ? new TranslateBrowserLoader(transferState, httpClient, prefix)
    : new TranslateFSLoader(transferState, prefix);
}
```

The `suffix` would have to be handled in the `getTranslation` method of each loader since we need access to the `lang` variable.

First, we need to get a hold of the autogenerated `map.json` file.

```ts
const i18nMap = require('../../assets/i18n/autogen/map.json');
```

We use a `require` syntax because this file might only be available during compilation.

The `TranslateBrowserLoader` will have the following changes:

```ts
const suffix = `.${i18nMap[lang]}${this.suffix}`;

return data
  ? of(data)
  : new TranslateHttpLoader(this.http, this.prefix, suffix).getTranslation(lang);
```

For the `TranslateFSLoader`, it is a one-line code change.

```ts
const path = join(__dirname, '../browser', this.prefix, `${lang}.${i18nMap[lang]}${this.suffix}`);
```

Compile and run the app. Everything will work as expected and the browser will load updated translation files when it needs to.


*** The final code is available [here](https://github.com/DmitryEfimenko/ssr-with-i18n).

## üëè Article Summary

In this article, we built a maintainable solution for managing application translation strings via separate JSON files. We utilized a popular library‚Ää-‚Äängx-translate. We've also looked at the current solutions for integrating this functionality with Server-Side Rendered applications provided by the community. We talked about the weaknesses of these solutions and provided better options. Finally, we implemented a few of the advanced features, such as: (1) memorization of the selected language via Cookies, (2) utilizing State Transfer to avoid unnecessary HTTP requests to the server, and (3) breaking cache for the translation files.

**Special thanks to [Ana Boca](http://anaboca.github.io/) and [Alex Bashmakov](https://github.com/abashmak) for reviewing, testing, and providing some of the code for this article.**

## Call to Action
I always enjoy feedback, so please üëè, üìù, and subscribe to AngularInDepth publication.

